import tkinter as tk
from tkinter import filedialog, messagebox
import nmap
import socket
import threading

# Global variable to track scan cancellation
cancel_scan_flag = False

def scan_open_ports(target, output_box, scan_type='basic'):
    global cancel_scan_flag
    try:
        nm = nmap.PortScanner()
        output_box.insert(tk.END, f"Scanning {target} for open ports...\n")

        # Select scanning options based on user input
        if scan_type == 'basic':
            output_box.insert(tk.END, "Running basic scan (top 100 ports)...\n")
            nm.scan(target, arguments='-F')  # Basic scan of top 100 ports

        elif scan_type == 'tcp_connect':
            output_box.insert(tk.END, "Running TCP Connect Scan...\n")
            nm.scan(target, arguments='-sT')  # TCP Connect Scan

        elif scan_type == 'syn':
            output_box.insert(tk.END, "Running SYN Scan...\n")
            nm.scan(target, arguments='-sS')  # SYN Scan

        elif scan_type == 'udp':
            output_box.insert(tk.END, "Running UDP Scan...\n")
            nm.scan(target, arguments='-sU')  # UDP Scan

        elif scan_type == 'version':
            output_box.insert(tk.END, "Running Service Version Detection...\n")
            nm.scan(target, arguments='-sV --version-all')  # Added --version-all for detailed version detection

        elif scan_type == 'os_detection':
            output_box.insert(tk.END, "Running OS Detection...\n")
            nm.scan(target, arguments='-O --osscan-guess')  # Added --osscan-guess for better results
            
            # Check if osclass is available
            if 'osclass' in nm[target] and nm[target]['osclass']:
                output_box.insert(tk.END, "Operating System Classes:\n")
                for os_class in nm[target]['osclass']:
                    output_box.insert(tk.END, f"  - {os_class['osfamily']} {os_class['osgen']}\n")
            else:
                output_box.insert(tk.END, "No OS information found in osclass.\n")

            # Check if osmatch is available
            if 'osmatch' in nm[target] and nm[target]['osmatch']:
                output_box.insert(tk.END, "OS Match Results:\n")
                for os_match in nm[target]['osmatch']:
                    output_box.insert(tk.END, f"  - {os_match['name']} (Accuracy: {os_match['accuracy']}%)\n")
            else:
                output_box.insert(tk.END, "No OS information found in osmatch.\n")

        elif scan_type == 'aggressive':
            output_box.insert(tk.END, "Running Aggressive Scan...\n")
            try:
                nm.scan(target, arguments='-A')  # Aggressive Scan
            except Exception as e:
                output_box.insert(tk.END, f"Error: {e}\n")

            if 'osclass' in nm[target]:
                output_box.insert(tk.END, "Operating System Classes:\n")
                for os_class in nm[target]['osclass']:
                    output_box.insert(tk.END, f"  - {os_class['osfamily']} {os_class['osgen']}\n")
            else:
                output_box.insert(tk.END, "No OS information found.\n")

            if 'osmatch' in nm[target]:
                output_box.insert(tk.END, "OS Match Results:\n")
                for os_match in nm[target]['osmatch']:
                    output_box.insert(tk.END, f"  - {os_match['name']} (Accuracy: {os_match['accuracy']}%)\n")
            else:
                output_box.insert(tk.END, "No OS match results found.\n")

        # Check if any hosts were found
        if nm.all_hosts() == []:
            output_box.insert(tk.END, "No hosts found. Please check your target and network settings.\n")
            return

        scanned_ports = 0

        for host in nm.all_hosts():
            output_box.insert(tk.END, f"\nHost: {host} ({nm[host].hostname()})\n")
            output_box.insert(tk.END, f"State: {nm[host].state()}\n")
            for proto in nm[host].all_protocols():
                output_box.insert(tk.END, f"Protocol: {proto}\n")
                lport = nm[host][proto].keys()
                for port in lport:
                    if cancel_scan_flag:
                        output_box.insert(tk.END, "\nScan canceled by user.\n")
                        return
                    output_box.insert(tk.END, f"Port: {port}\tState: {nm[host][proto][port]['state']}\n")
                    scanned_ports += 1

        output_box.insert(tk.END, f"\nScan command used: {nm.command_line()}\n")

    except Exception as e:
        output_box.insert(tk.END, f"Error: {e}\n")


def run_scan(target_entry, output_box, scan_type):
    global cancel_scan_flag
    cancel_scan_flag = False  # Reset cancel flag before starting new scan

    target = target_entry.get()
    if target:
        try:
            socket.gethostbyname(target)  # Validate target input
            output_box.delete(1.0, tk.END)  # Clear output box

            # Run scan in a separate thread
            threading.Thread(target=scan_open_ports, args=(target, output_box, scan_type)).start()

        except socket.gaierror:
            messagebox.showerror("Invalid Input", "Please enter a valid target IP or domain.")
    else:
        messagebox.showwarning("Input Error", "Please enter a target IP or domain.")


def cancel_scan(output_box):
    global cancel_scan_flag
    cancel_scan_flag = True
    output_box.insert(tk.END, "Scan cancellation requested...\n")


def save_scan(output_box):
    file = filedialog.asksaveasfile(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
    if file:
        try:
            scan_results = output_box.get(1.0, tk.END)
            file.write(scan_results)  # Write results to file
            file.close()
            messagebox.showinfo("Success", "Scan results saved successfully!")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save the file: {e}")


def create_gui():
    root = tk.Tk()
    root.title("Advanced Vulnerability Scanner")

    # Target Entry
    tk.Label(root, text="Target (IP or Domain):").pack(pady=5)
    target_entry = tk.Entry(root, width=50)
    target_entry.pack(pady=5)

    # Scan Type Selection
    scan_type_var = tk.StringVar(value='basic')
    tk.Label(root, text="Select Scan Type:").pack(pady=5)
    scan_type_frame = tk.Frame(root)
    scan_type_frame.pack(pady=5)
    tk.Radiobutton(scan_type_frame, text="Basic Scan", variable=scan_type_var, value='basic').pack(side="left", padx=10)
    tk.Radiobutton(scan_type_frame, text="TCP Connect Scan", variable=scan_type_var, value='tcp_connect').pack(side="left", padx=10)
    tk.Radiobutton(scan_type_frame, text="SYN Scan", variable=scan_type_var, value='syn').pack(side="left", padx=10)
    tk.Radiobutton(scan_type_frame, text="UDP Scan", variable=scan_type_var, value='udp').pack(side="left", padx=10)
    tk.Radiobutton(scan_type_frame, text="Service Version Detection", variable=scan_type_var, value='version').pack(side="left", padx=10)
    tk.Radiobutton(scan_type_frame, text="OS Detection", variable=scan_type_var, value='os_detection').pack(side="left", padx=10)
    tk.Radiobutton(scan_type_frame, text="Aggressive Scan", variable=scan_type_var, value='aggressive').pack(side="left", padx=10)

    # Output Box
    output_box = tk.Text(root, height=20, width=80)
    output_box.pack(pady=10)

    # Scan Buttons
    button_frame = tk.Frame(root)
    button_frame.pack(pady=10)
    tk.Button(button_frame, text="Run Scan", command=lambda: run_scan(target_entry, output_box, scan_type_var.get())).pack(side="left", padx=5)
    tk.Button(button_frame, text="Cancel Scan", command=lambda: cancel_scan(output_box)).pack(side="left", padx=5)
    tk.Button(button_frame, text="Save Scan", command=lambda: save_scan(output_box)).pack(side="left", padx=5)

    root.mainloop()

if __name__ == "__main__":
    create_gui()
